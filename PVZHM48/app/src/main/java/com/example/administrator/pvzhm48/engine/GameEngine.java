package com.example.administrator.pvzhm48.engine;import android.view.MotionEvent;import com.example.administrator.pvzhm48.domain.Nut;import com.example.administrator.pvzhm48.domain.PeaPlant;import com.example.administrator.pvzhm48.domain.PrimaryZombie;import com.example.administrator.pvzhm48.domain.ShowPlant;import com.example.administrator.pvzhm48.domain.Sun;import com.example.administrator.pvzhm48.domain.SunPlant;import com.example.administrator.pvzhm48.domain.base.Plant;import com.example.administrator.pvzhm48.layer.FightLayer;import com.example.administrator.pvzhm48.utils.CommonUtils;import org.cocos2d.actions.CCProgressTimer;import org.cocos2d.actions.CCScheduler;import org.cocos2d.layers.CCTMXTiledMap;import org.cocos2d.nodes.CCDirector;import org.cocos2d.nodes.CCSprite;import org.cocos2d.types.CGPoint;import org.cocos2d.types.CGRect;import java.util.ArrayList;import java.util.Random;import java.util.concurrent.CopyOnWriteArrayList;/** * 专门处理战斗逻辑的类 单例类 * * @author Kevin * */public class GameEngine {    private static GameEngine mInstance = new GameEngine();    private CCTMXTiledMap map;    private CopyOnWriteArrayList<ShowPlant> mSelectedPlants;    public static boolean isStart;// 标记游戏是否正式开始    private ArrayList<CGPoint> mZombeiPoints;    private static ArrayList<FightLine> mFightLines;    private int progress;// 僵尸加载的进度    // 初始化5条战线    static {        mFightLines = new ArrayList<FightLine>();        for (int i = 0; i < 5; i++) {            FightLine line = new FightLine(i);            mFightLines.add(line);        }    }    private GameEngine() {    }    public static GameEngine getInstance() {        return mInstance;    }    /**     * 游戏开始     */    public void gameStart(CCTMXTiledMap map,                          CopyOnWriteArrayList<ShowPlant> selectedPlants) {        isStart = true;        this.map = map;        this.mSelectedPlants = selectedPlants;        mZombeiPoints = CommonUtils.loadPoint(map, "road");// 加载僵尸移动路径        // 定时器        CCScheduler shceduler = CCScheduler.sharedScheduler();        shceduler.schedule("loadZombie", this, 2, false);// 每隔两秒,执行一次loadZombie方法        // loadZombie();        loadPlantPoints();        progress();// 显示进度条    }    private CGPoint[][] mPlantPoints = new CGPoint[5][9];// 初始化二维数组,保存植物坐标点    /**     * 加载植物坐标点     */    private void loadPlantPoints() {        String format = "tower%02d";        for (int i = 1; i <= 5; i++) {            ArrayList<CGPoint> loadPoint = CommonUtils.loadPoint(map,                    String.format(format, i));            for (int j = 0; j < loadPoint.size(); j++) {                mPlantPoints[i - 1][j] = loadPoint.get(j);            }        }    }    /**     * 加载僵尸 float参数必须有,否则CCScheduler无法通过反射调用     */    public void loadZombie(float f) {        // System.out.println("float:" + f);        Random random = new Random();        int line = random.nextInt(5);// 0,1,2,3,4        CGPoint startPoint = mZombeiPoints.get(line * 2);// 起点坐标        CGPoint endPoint = mZombeiPoints.get(line * 2 + 1);// 终点坐标        PrimaryZombie zombie = new PrimaryZombie(startPoint, endPoint);        map.addChild(zombie, 1);        mFightLines.get(line).addZombie(zombie);// 把僵尸添加到战线中        progress += 5;// 每加载一个僵尸,进度增加5        progressTimer.setPercentage(progress);// 更新进度条进度    }    private ShowPlant mShowPlant;// 当前被点击的已选植物    private Plant mPlant;// 当前要安放的植物    /**     * 专门处理点击事件     *     * @param event     */    public void handleTouch(MotionEvent event) {        CGPoint convertTouchToNodeSpace = map.convertTouchToNodeSpace(event);        CCSprite selectedBox = (CCSprite) map.getParent().getChildByTag(                FightLayer.TAG_SELECTED_BOX);        if (CGRect.containsPoint(selectedBox.getBoundingBox(),                convertTouchToNodeSpace)) {// 已选框被点击            for (ShowPlant showPlant : mSelectedPlants) {                if (CGRect.containsPoint(showPlant.getShowPlant()                        .getBoundingBox(), convertTouchToNodeSpace)) {                    if (mShowPlant != null) {                        mShowPlant.getShowPlant().setOpacity(255);// 将上一个植物设置为不透明                    }                    mShowPlant = showPlant;                    showPlant.getShowPlant().setOpacity(100);                    switch (mShowPlant.getId()) {                        case 1:                            mPlant = new PeaPlant();// 安放豌豆射手                            break;                        case 2:                            mPlant = new SunPlant();//安放向日葵                            break;                        case 4:                            mPlant = new Nut();// 安放土豆                            break;                        default:                            break;                    }                    break;                }            }        } else {// 鼠标落在草坪上            if (isInGrass(convertTouchToNodeSpace)) {// 判断是否在草坪的格子里                System.out.println("在格子里面");                if (mPlant != null && mShowPlant != null) {                    map.addChild(mPlant);// 安放植物                    mShowPlant.getShowPlant().setOpacity(255);// 设置不透明                    // 给战线添加植物                    mFightLines.get(mPlant.getLine()).addPlant(mPlant);                    mPlant = null;                    mShowPlant = null;                }            }        }        //判断阳光是否被点击        CopyOnWriteArrayList<Sun> suns = Sun.suns;        for(Sun sun :suns){            if(CGRect.containsPoint(sun.getBoundingBox(),                    convertTouchToNodeSpace)){//阳光被点击                sun.collectAction();//收集阳光                break;            }        }    }    /*     * 判断是否在草坪的格子里     */    private boolean isInGrass(CGPoint point) {        int column = (int) (point.x / 46);// 计算第几列        int line = (int) ((CCDirector.sharedDirector().winSize().height - point.y) / 54);// 第几行        if (column >= 1 && column <= 9 && line >= 1 && line <= 5) {            if (mPlant != null) {                mPlant.setLine(line - 1);// 设置行号列号                mPlant.setColumn(column - 1);                mPlant.setPosition(mPlantPoints[line - 1][column - 1]);// 设置植物的位置                if (mFightLines.get(line - 1).contaionsPlant(mPlant)) {// 判断战线是否包含植物                    return false;                }                return true;            }        }        return false;    }    CCProgressTimer progressTimer;    /**     * 更新进度     */    private void progress() {        progressTimer = CCProgressTimer                .progressWithFile("image/fight/progress.png");// 初始化一个进度条        progressTimer.setPosition(                CCDirector.sharedDirector().getWinSize().width - 70, 13);        map.getParent().addChild(progressTimer);// 显示在屏幕上        progressTimer.setScale(0.6f);// 缩放        // 0-100        progressTimer.setPercentage(0);// 每增加一个僵尸需要调整进度，增加5 0-100        // 设置样式        progressTimer                .setType(CCProgressTimer.kCCProgressTimerTypeHorizontalBarLR);// 水平进度条,从左向右更新        // 进度条的外壳        CCSprite sprite = CCSprite.sprite("image/fight/flagmeter.png");        sprite.setPosition(CCDirector.sharedDirector().getWinSize().width - 70,                13);        map.getParent().addChild(sprite);        sprite.setScale(0.6f);        // 关卡进程        CCSprite name = CCSprite                .sprite("image/fight/FlagMeterLevelProgress.png");        name.setPosition(CCDirector.sharedDirector().getWinSize().width - 70, 5);        map.getParent().addChild(name);        name.setScale(0.6f);    }}